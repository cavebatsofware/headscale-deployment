# Deployment Guide

This walks through deploying the Headscale infrastructure from scratch. Adapt each step to your environment.

## 1. Configuration

### Nix deployment config

```sh
cp nix/deployment-config.json.example nix/deployment-config.json
```

Minimal required values:

```json
{
  "domain": "example.com",
  "acmeEmail": "admin@example.com",
  "adminIP": "203.0.113.10",
  "keycloakPrivateIP": "10.0.1.20"
}
```

See [NIXOS.md](NIXOS.md) for the full option reference.

### Terraform variables

```sh
cp infra/terraform/environments/prod/terraform.tfvars.example \
   infra/terraform/environments/prod/terraform.tfvars
```

Fill in your OCI credentials, compute shapes, SSH key, and domain settings. The example file documents each variable.

## 2. Infrastructure Provisioning

```sh
cd infra/terraform/environments/prod
tofu init
tofu plan    # Review changes
tofu apply   # Create resources
```

Terraform creates the VCN, subnets, OCI Vault with secrets, IAM policies for instance principal auth, compute instances, and DNS records (if using the Route53 module).

Most secrets are auto-generated by Terraform (DB passwords, Keycloak admin password, Headplane cookie secret). Two secrets are created as placeholders and must be updated manually after initial setup:

- **OIDC client secret** - update after creating the Keycloak client (step 5)
- **DERP pre-auth key** - update after Headscale is running (step 6)

Instance metadata passes each VM the OCIDs of the secrets it needs. At boot, each VM's `secrets-init` service fetches its secrets from the vault using instance principal authentication.

## 3. Building NixOS Images

### Using oci-image-builder (recommended)

The Go CLI tool handles the full lifecycle - build, upload, and import:

```sh
cd tools/oci-image-builder
go build -o oci-image-builder ./

# Initialize config (first time):
./oci-image-builder init

# Build, upload, and import all images:
./oci-image-builder all

Run `./oci-image-builder --help` for all commands and flags.

### Using nix directly

```sh
nix build .#oci-headscale-image
ls -lh result/nixos.qcow2
```

You'll then need to manually upload the QCOW2 to OCI Object Storage and import it as a Custom Image.

## 4. Launching Instances

After importing images, update the image OCIDs in `terraform.tfvars` and run `tofu apply` to create or replace instances. Boot order matters - Keycloak should be running before Headscale starts (Headscale waits for OIDC availability).

## 5. Post-Deploy: Keycloak Setup

Once the Keycloak VM boots and `secrets-init` completes:

1. Log in at `https://keycloak.yourdomain.com` with the bootstrap admin credentials from the vault
2. Create a realm (default name: `headscale`)
3. Create an OIDC client (default ID: `headscale`)
4. Copy the client secret and update the OIDC vault secret:
   ```sh
   oci vault secret update-base64 --secret-id <oidc-secret-ocid> \
     --secret-content-content "$(echo -n '<client-secret>' | base64)"
   ```
5. Set redirect URIs on the client:
   - `https://headscale.yourdomain.com/oidc/callback`
   - `https://headscale.yourdomain.com/admin/oidc/callback`

## 6. Post-Deploy: DERP Exit Node

After Headscale is running, create a pre-auth key and store it in the vault:

```sh
# On the headscale VM:
headscale preauthkeys create --user infraexit

# Then update the vault secret:
oci vault secret update-base64 --secret-id <derp-preauth-secret-ocid> \
  --secret-content-content "$(echo -n '<preauth-key>' | base64)"
```

Reboot or restart `secrets-init` on the DERP VM to pick up the key. Once it joins the tailnet:

```sh
# The below can be done on headplane also once that is setup with Keycloak
# On the headscale VM, enable the exit node route:
headscale routes list
headscale routes enable -r <route-id>
```

The pre-auth key is only needed on first boot. Subsequent boots reconnect using stored Tailscale state.

## 7. Updating Running Instances

### Incremental updates (nixos-rebuild)

For configuration changes that don't require a full image rebuild, push updates directly to running instances:

```sh
# Build the new configuration locally and activate it on the remote host:
nixos-rebuild switch --flake ".#headscale" \
  --target-host root@headscale.yourdomain.com

# Same for other hosts:
nixos-rebuild switch --flake ".#keycloak" \
  --target-host root@keycloak.yourdomain.com

nixos-rebuild switch --flake ".#derp-east" \
  --target-host root@derp-east.yourdomain.com
```

This builds the system closure locally, copies it to the remote host over SSH, and activates it in place. No reboot required unless the kernel or initrd changed. This is usually the easiest and fastest way to update instances when changes are needed and is fairly easy to automate with CI/CD tools.

If your builder does not use the same arch as your image / target shape the builder will (very likely) need to configured to handle cross-arch nix builds properly and that also applies to building the qcow images. Its recommended to just build on the same arch as the target when possible. Nix does support remote image building and oci-image-builder automates this, but that functionality is not covered in detail here. I leave that more as a "make your own adventure" thing for anyone interested.

The `oci-hardware.nix` module is included in the flake's `nixosConfigurations` specifically to support this - it provides the hardware config that `nixos-rebuild` expects but that the image builder normally handles via `nixos-generators`.

### Full image rebuild

When you need a clean image (provisioning a new instance, new system block device, or updating stored custom images):

1. Build and import new images with `oci-image-builder all` (or `nix build`)
2. Update the image OCID in `terraform.tfvars`
3. Taint the instance so Terraform will recreate it:
   ```sh
   tofu taint module.compute.oci_core_instance.INSTANCE_NAME
   tofu apply
   ```
   Changing the image OCID alone does not trigger instance replacement unless the resource is tainted or the lifecycle is configured to do so.

## 8. Verification

Each VM includes health check scripts:

```sh
# Headscale VM:
headscale-health       # Headscale API
headscale-status       # Service status + recent logs

# Keycloak VM:
keycloak-health        # Keycloak /health/ready
postgres-health        # PostgreSQL
service-status         # Both services + logs

# DERP VM:
derp-health            # DERP + STUN ports
derp-status            # Service status + Tailscale status + logs
```